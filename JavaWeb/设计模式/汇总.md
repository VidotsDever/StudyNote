**策略模式(Strategy)**：

* 解释：在运行时改变算法的行为；
* 例子：购物时有不同类型(春节50%、国庆节30%)的折扣；
* 实现：定义接口，不同的策略实现该接口；

**代理模式(Proxy)：**

* 解释：一个类表示另一个类的功能；
* 例子：服务提供商的代理商(确保实现服务提供商的所有功能)；
* 实现：创建包含原始对象的代理对象，实现同样的接口；

**享元模式(Flyweight)：**

* 解释：重用已经创建出来的相似类型的对象(通过将对象存储起来)，只有在没找到匹配的对象时才创建新的对象。
* 例子：工厂生产汽车，而这些汽车是根据颜色来区分型号，其它属性无关紧要；
* 实现：定义工厂类，并在工厂类中使用`Map`存储创建出来的对象；

**状态模式(State)：**

* 解释：类的行为会基于它的状态而发生改变；
* 例子：要将一个包裹送往邮局，包裹可能处于上门取件中、运输途中、被客户签收这些状态。可以基于当前状态，来打印出当前运输状态；
* 实现：定义上下文类，该类包含一个关联的状态类(在程序执行过程中会发生改变)；

**装饰器模式：**

* 解释：向对象中添加额外的职责；
* 例子：我们有一棵圣诞树，想要装饰它；我们没有改变圣诞树本身，只是添加一些装饰小配件，比如灯光等；
* 实现：通过组合的方式，首先创建装饰器的抽象类，然后让具体的装饰器类来继承该抽象类。

**参观者模式：**

* 解释：向结构的每个元素中添加一个函数，该函数接受参观者类；
* 例子：电脑由许多组件构成，参观者类中有对应的方法访问这些组件；
* 实现：创建一个接口代表元素，该接口里定义的函数结构参观者；定义参观者接口，该接口里定义参观各个元素的方法；

**桥接模式：**

* 解释：将抽象与实现解耦；
* 例子：绘制形状时，先定义颜色相关的接口和类，然后在形状类中引用颜色；
* 实现：在一个抽象类中引用另一个类；

**原型模式：**

* 解释：当我们有一个类的实例时，想要只通过拷贝来创建新的对象；
* 例子：在游戏中需要渲染大量的树，首先创建一颗树，然后从原型中拷贝树，只需要更改位置即可；
* 实现：定义包含copy()方法的接口，并让具体类实现；























































